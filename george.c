#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <sys/select.h>
#include <netinet/in.h>

int sockfd, maxfd, ids[FD_SETSIZE], cnt = 0;
struct sockaddr_in servaddr;
fd_set currfd, readfd;
char serv_buf[50], cli_buf[50];

void err42(char *s)
{
    write(2, s, strlen(s));
    exit(1);
}
// Функция s_msg в этой программе используется для отправки сообщения всем клиентам,
// подключённым к серверу, кроме клиента, от которого сообщение пришло. Она принимает
// три параметра:

// cli_fd: файловый дескриптор клиента, от которого поступило сообщение (это клиент,\
// которому сообщение НЕ нужно отправлять).
// buf: буфер, содержащий сообщение, которое нужно разослать.
// len: длина сообщения.

void s_msg(int cli_fd, char *buf, int len)
{
// Цикл по всем файловым дескрипторам: функция проходит по всем дескрипторам от 0 до maxfd,
// где maxfd — это максимальный дескриптор, который используется в программе (с каждым
// новым клиентом значение maxfd обновляется).
    for (int fd = 0; fd <= maxfd; fd++)
    // Проверка клиента: if (fd != cli_fd). Если текущий дескриптор fd не равен cli_fd,
    // значит, это не клиент, от которого пришло сообщение, и сообщение должно быть
    // отправлено на этот дескриптор.
        if (fd != cli_fd)
        // Отправка сообщения: если условие соблюдено, функция вызывает send для отправки
        // данных, хранящихся в buf, длиной len, по сети клиенту с дескриптором fd.
            send(fd, buf, len, 0);
}
// Функция send_msg обрабатывает и пересылает сообщение от клиента всем остальным
// подключённым клиентам. Её работа заключается в поочерёдной передаче символов из
// сообщения, а также в пересылке информации о том, какой именно клиент отправил это
// сообщение
// fd: файловый дескриптор клиента, от которого поступило сообщение.
// len: длина сообщения, хранящегося в буфере cli_buf.
void send_msg(int fd, int len)
{
    // Добавление идентификатора клиента: создаётся строка вида "client N: ", 
    // где N — это идентификатор клиента. Строка помещается в буфер serv_buf.
    sprintf(serv_buf, "client %d: ", ids[fd]);
    // Отправка клиентского идентификатора: функция s_msg используется для отправки
    // этой строки всем клиентам, кроме отправителя. Это делает сообщение более информативным,
    // добавляя метку с идентификатором клиента
    s_msg(fd, serv_buf, strlen(serv_buf));
    // Цикл по символам сообщения: создаётся массив send, предназначенный для отправки
    // символов по одному. Цикл проходит по каждому символу в cli_buf, копируя его в send[0].
    char send[2] = {};
    // Отправка символа: каждый символ передаётся всем клиентам с помощью s_msg, за
    //  исключением отправителя.
    for (int i = 0; i < len; i++)
    {
        send[0] = cli_buf[i];
        s_msg(fd, send, strlen(send));
        // Отправка символа: каждый символ передаётся всем клиентам с помощью s_msg, за
        // исключением отправителя.
        if (i + 1 < len && send[1] == '\n')
            s_msg(fd, serv_buf, strlen(serv_buf));
        // Добавление идентификатора при переносе строки: если следующий символ — это символ
        // новой строки (\n), то программа снова отправляет идентификатор клиента, делая формат
        // сообщений более читаемым, если оно занимает несколько строк.
        if (i + 1 == len && len == 50)
        {
            // Обработка длинного сообщения: если len равно 50, это означает, что сообщение
            // могло быть слишком длинным и не поместилось в буфер cli_buf. В таком случае
            // программа вызывает recv, чтобы прочитать следующие 50 байт данных от клиента,
            // и сбрасывает i на -1, чтобы начать обрабатывать новые данные с начала цикла.
            len = recv(fd, cli_buf, 50, 0);
            i = -1;
        }
    }
}
// Этот фрагмент кода инициализирует сервер, настраивает его на прослушивание входящих
// подключений и подготавливает набор дескрипторов для работы с клиентами. Рассмотрим
// каждую часть по отдельности.
int main(int ac, char **av)
{
    if (ac != 2)
        err42("Wrong number of arguments\n");

    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd == -1)
        err42("Fatal error\n");

    bzero(&servaddr, sizeof(servaddr));
    servaddr.sin_family = AF_INET;
    servaddr.sin_addr.s_addr = htonl(2130706433); //127.0.0.1
    servaddr.sin_port = htons(atoi(av[1]));

    if (bind(sockfd, (const struct sockaddr *)&servaddr, sizeof(servaddr)) != 0)
        err42("Fatal error\n");
    // Переключение в режим прослушивания: listen(sockfd, 10) переводит сокет в режим прослушивания,
    // позволяя ему принимать входящие подключения. Параметр 10 задаёт максимальную длину очереди подключений
    if (listen(sockfd, 10) != 0)
        err42("Fatal error\n");
    // Инициализация множеств дескрипторов: FD_ZERO очищает множества currfd и readfd, которые будут
    // использоваться для отслеживания активных дескрипторов.
    FD_ZERO(&currfd);
    FD_ZERO(&readfd);
    // Добавление серверного сокета в множество: FD_SET(sockfd, &currfd) добавляет серверный сокет
    // в множество currfd, которое будет использоваться при вызове select для отслеживания активных
    // дескрипторов
    FD_SET(sockfd, &currfd);
    maxfd = sockfd;

    while (1)
    {
        // Копирование множества дескрипторов: currfd — это множество всех активных дескрипторов,
        // с которыми работает сервер. readfd — это временное множество, которое передаётся в select.
        // Копирование позволяет сохранить оригинальное currfd, так как select изменяет переданное множество
        // дескрипторов.
        readfd = currfd;
        // Вызов select: функция select ждёт активности на любом из дескрипторов в readfd. Параметр
        // maxfd + 1 задаёт диапазон проверки дескрипторов, от 0 до maxfd. Если на каком-либо дескрипторе
        // обнаружена активность, select вернёт положительное значение; если произошла ошибка, select вернёт
        // отрицательное значение, и цикл перейдёт к следующей итерации.
        if (select(maxfd + 1, &readfd, 0, 0, 0) < 0)
            continue;
        // Проверка активности дескриптора: цикл проходит по всем дескрипторам до maxfd. FD_ISSET(fd, &readfd)
        // проверяет, был ли обнаружен активный дескриптор, требующий обработки. Если дескриптор не активен,
        // цикл переходит к следующему дескриптору.
        for (int fd = 0; fd <= maxfd; fd++)
        {
            if (!(FD_ISSET(fd, &readfd)))
                continue;
        // Проверка серверного сокета: если активен дескриптор sockfd (серверный сокет), это означает,
        // что поступил новый запрос на подключение от клиента.                
            if (sockfd == fd)
            {
                // Принятие подключения: accept создаёт новый сокет для клиента, возвращая его файловый дескриптор cli_fd
                int cli_fd = accept(sockfd, 0, 0);
                if (cli_fd > maxfd)
                    maxfd = cli_fd;
                // Добавление нового клиента: новый дескриптор добавляется в currfd с помощью FD_SET, и клиент
                // получает уникальный идентификатор, который сохраняется в ids[cli_fd]
                ids[cli_fd] = cnt++;
                FD_SET(cli_fd, &currfd);
                sprintf(serv_buf, "server: client %d just arrived\n", ids[cli_fd]);
                s_msg(cli_fd, serv_buf, strlen(serv_buf));
            }
            else
            {
                // Получение данных: если активный дескриптор fd не является серверным сокетом, значит, он принадлежит
                // одному из клиентов. Вызов recv получает данные от клиента и сохраняет их в cli_buf, возвращая
                // количество полученных байт в len
                int len = recv(fd, cli_buf, 50, 0);
                if (len > 0)
                {
                    send_msg(fd, len);
                }
                else
                {
                    sprintf(serv_buf, "server: client %d just left\n", ids[fd]);
                    s_msg(fd, serv_buf, strlen(serv_buf));
                    FD_CLR(fd, &currfd);
                    close(fd);
                }
            }
        }
    }
}